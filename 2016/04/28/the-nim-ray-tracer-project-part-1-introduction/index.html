<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width;target-densityDpi=160;initial-scale=1;maximum-scale=1"><meta name=description content="Personal blog of John Novak"><meta name=author content="John Novak"><title>The Nim Ray Tracer Project &mdash; Part 1: Introduction | John Novak</title><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;1,400;1,600;1,700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Astloch&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=UnifrakturMaguntia&display=swap" rel=stylesheet><link rel=stylesheet href=https://blog.johnnovak.net/sass/blog.0b95c1044114d563a535c52ab83188514fd5a237e4a402c924e77ccb19b2e3a3.css type=text/css><link rel=stylesheet href=/css/jqmath-0.4.3.css type=text/css><link rel=stylesheet href=/css/photoswipe.css type=text/css><script src=/js/lib/jquery-1.12.4.min.js></script><script src=/js/lib/jqmath-etc-0.4.6.min.js></script><script src=/js/blog.js></script><link rel=alternate type=application/rss+xml title="Recent posts" href=https://blog.johnnovak.net/index.xml></head><body><div id=wrapper><header id=header><div id=header-bg></div><a href=/><img id=jn-logo src=/img/jn-logo.png alt="John Novak" data-2x=/img/jn-logo@2x.png></a><p class=tagline>Riding on the tail of the<br>Gaussian curve<br>since 1979</p><nav><ul><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li class=last><a href=/tags/>Tags</a></li></ul></nav></header><div role=main><article class=post><header><h1><a href=/2016/04/28/the-nim-ray-tracer-project-part-1-introduction/>The Nim Ray Tracer Project &mdash; Part 1: Introduction</a></h1><p class=date><time datetime=2016-04-28>2016 Apr 28</time></p></header><nav class=tags><ul><li><a href=/tags/graphics/>graphics</a></li><li><a href=/tags/ray-tracing/>ray tracing</a></li><li><a href=/tags/nim/>nim</a></li></ul></nav><section class=intro><p>[Listening to the albums <em>Reverberant Skies</em> and <em>White Maps</em> from
<em>Aglaia</em> in an infinite loop&mldr; A beautifully hypnotic experience! The track
<em>In the First Spinning Place</em> from <em>White Maps</em> is my absolute favourite.]</p></section><h2 id=why-a-ray-tracer>Why a ray tracer?</h2><p>I&rsquo;ve been fascinated by ray tracing since my childhood. I still remember the
first time I was playing around with an early 3D modeller/ray tracer program
on the <a href=https://en.wikipedia.org/wiki/Amiga_500>Amiga 500</a> called
<a href=https://en.wikipedia.org/wiki/Imagine_%283D_modeling_software%29>Imagine</a>
when I was about 13, trying to render some extruded letters made of glass
placed on a classic checker-board patterned surface (don&rsquo;t laugh, this was
sort of a novel thing to do at that time, and I was a kid). Well, rendering
the final 360x576 image (<a href=https://en.wikipedia.org/wiki/Overscan>overscan</a>!)
took a bit more than 7 hours, but when I turned on the monitor in the morning
in great anticipation and saw the final image in its
<a href=https://en.wikipedia.org/wiki/Hold-And-Modify>4096-colour</a> interlaced glory
(probably quite primitive looking by today&rsquo;s standards), I was in awe! What
made the experience even more interesting for me was that Imagine supported
the use of so-called procedural textures, which are textures solely generated
by mathematical functions instead of using bitmap images. I was mesmerised&mdash;a
photorealistic image generated by the computer using nothing else but pure
maths! <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><p>I have always thought of ray tracing as some kind of black magic&mdash;something
utterly fascinating and very scary at the same time because of the complex
maths involved (which, as it turns out, is not quite true). This belief was
also strengthened by my modest excursions into OpenGL programming years later,
which uses a different method called
<a href=https://en.wikipedia.org/wiki/Rasterisation>rasterization</a> to generate 3D
images.</p><h2 id=ray-tracing-vs-rasterization>Ray tracing vs rasterization</h2><p>Historically, there have been two main disparate approaches to rendering 3D
scenes, rasterization and ray tracing (the situation is not so clear-cut
nowadays, as we&rsquo;ll see later). While rasterization is by several orders of
magnitude more efficient at producing 3D animations at smooth frame rates in
real-time, ray tracing can produce vastly more photorealistic results. While
many visual effects that happen in real life, such as non-planar reflections,
soft shadows, refractions and caustics, are quite simple, albeit
computationally very costly, to calculate with ray tracing, it requires quite
a bit of complicated trickery even just to fake them with rasterization.</p><p>At the risk of grossly oversimplifying matters, rasterization is very
efficient at projecting several hundreds of thousands of three-dimensional
triangles onto a two-dimensional surface (the screen) and then colouring
(shading) them according to some rules. In order to obtain reasonable frame
rates during real-time animation, certain simplifications and optimisations
have to be made. Photorealistic rendering that accurately portrays how a given
scene would look in real life is not necessarily of primary importance as long
as the end result looks pleasing (which is a reasonable assumption for many
applications such as visualisation and games, where absolute fidelity to
reality is not a requirement). It&rsquo;s the 3D artists' job to arrange those
coloured triangles so that the resulting image looks good. Most
graphics-accelerator cards today implement some sort of rasterization pipeline
in hardware.</p><p><a href=https://en.wikipedia.org/wiki/Ray_tracing_(graphics)>Ray tracing</a>, on the
other hand, is a pretty much a no-holds-barred approach of generating
realistic images on a computer by simulating the path of photons emitted by
light sources bouncing from surface to surface among the objects making
up the 3D scene, finally landing on the image surface of the virtual camera.
Photorealism is of primary importance here, which is achieved by calculating
the image pixel by pixel using algorithms that mimic the laws of physics as
closely as practically possible (certain simplifications must be made, of
course, otherwise we would end up writing a Universe Simulator!).</p><p>This begs the question, is ray tracing superior to rasterization then? In some
way, we can say it is. As far as photorealistic rendering is concerned, ray
tracing is hard to beat, however this comes at a very steep computational
cost. But if we asked whether it was possible to create pleasing imagery using
rasterization alone, the answer would be a yes again. Just because
rasterization is not as much rooted in physical reality as ray tracing, it
would be foolish to think that it&rsquo;s not capable of producing stellar results
that can look very convincingly real (just look at any modern game released
post 2010!). Indeed, there&rsquo;s nothing preventing skilful artists from arranging
the triangles making up the scene in such a way that can convey very realistic
final results&mdash;similarly to how a master painter can create astonishingly
realistic works of art by nothing more than applying differently coloured
specks of paint onto a canvas with a mere paintbrush.</p><figure class=image><a class=largeimg href=/2016/04/28/the-nim-ray-tracer-project-part-1-introduction/img/caravaggio.jpg data-pswp-width=800 data-pswp-height=822><img src=/2016/04/28/the-nim-ray-tracer-project-part-1-introduction/img/caravaggio.jpg alt="Caravaggio, The Calling of St Matthew" style=width:80% loading=lazy></a><figcaption style=width:80%>Surely, <a href=https://en.wikipedia.org/wiki/Caravaggio>Caravaggio</a> did not know about the <a href=https://en.wikipedia.org/wiki/Fresnel_equations>Fresnel equations</a> or the
<a href=https://en.wikipedia.org/wiki/Metropolis_light_transport>Metropolis light transport</a> when he painted <a href=https://en.wikipedia.org/wiki/The_Calling_of_St_Matthew_(Caravaggio)>The Calling of Saint Matthew</a>
in 1600. Yet no one would say his paintings are not realistic enough just
because he did not know about the physics of light! Interestingly enough,
there have been some <a href=http://www.webexhibits.org/hockneyoptics/post/grundy7.html>speculations</a> that he might have used the <a href=https://en.wikipedia.org/wiki/Camera_obscura>camera
obscura</a> to aid him in attaining his photorealistic results&mdash;the workings
of which have strong connections to the basic idea of ray tracing. Here we
go!</figcaption></figure><p>As CPUs and GPUs grew more powerful, previously purely
rasterization-based game engines have been increasingly incorporating ray
tracing techniques into their toolbox, such as <a href=https://blogs.unity3d.com/2014/09/18/global-illumination-in-unity-5/>global
illumination</a>,
<a href=https://twiik.net/articles/realtime-reflections-in-unity-5>real-time
reflections</a> and
<a href=https://vimeo.com/82659909>pseudo-refraction</a> using shaders. These techniques
are usually quite limited compared to their ray tracing counterparts, for
example global illumination is usually restricted to static objects,
reflections are only possible on planar surfaces and refraction is faked with
shaders.</p><p>Also, more and more game engines have started implementing <a href=http://blog.wolfire.com/2015/10/Physically-based-rendering>physically-based
rendering (PBR)</a>
methods recently, the renowned
<a href=https://en.wikipedia.org/wiki/CryEngine>CryEngine</a> being one notable
example. The following is the introductory paragraph of the <a href=https://docs.cryengine.com/display/SDKDOC2/Physically+Based+Shading>Physically Based
Shading</a>
chapter of the <a href=https://docs.cryengine.com/>CryEngine SDK
documentation</a>:</p><blockquote><p>CRYENGINE 3.6 and beyond uses a shading model that is based on fundamental
physical rules. Instead of using a plenty of fudge and tweak factors which
don&rsquo;t have a reasonable meaning in the real world, materials use some physical
properties to describe how the incoming light should interact with them.
A huge advantage of using a physically based model with certain rules is that
material assets will a lot more consistent and look more convincing under
different lighting conditions.</p></blockquote><p>This supports my earlier claim that while it&rsquo;s certainly possible to create
realistic visuals with rasterization, photorealism is not inherent in the
rendering algorithm, but requires manual tweaking and fine-tuning of various
parameters on the part of the 3D artist.</p><p>To sum up, I personally tend to think of rasterization as a more
artist-centric and ray tracing as a more scientific approach of image
generation. Ultimately, both are just tools of solving the problem of mapping
a 3D scene onto a 2D image surface, but there&rsquo;s a certain undeniable beauty
and elegance to ray tracing algorithms in how they generate complex visual and
optical effects by the application of just a few simplified physical models of
reality.</p><h3 id=in-defence-of-rasterization>In defence of rasterization</h3><p>Just to bring the point home that rasterization is not inferior to ray tracing
but only different, and to further support my argument that it is a more
artist-based approach to rendering, let me present two examples from the two
opposite ends of the spectrum of what rasterization is capable of. As we&rsquo;ll
see, it would have been difficult or impractical (or both) to achieve the same
results with pure ray tracing techniques alone in both cases.</p><p>The magical realist adventure game (whatever that means) <a href=http://kentuckyroutezero.com/>Kentucky Road
Zero</a> by the aptly titled developer <a href=http://cardboardcomputer.com/>Cardboard
Computer</a> uses clever rasterization tricks to
render its highly stylised low-polygon world. While the abstract visuals bear
similitude to simple 2D paper cut-outs in most scenes, some occasional camera
angle switches hint at it that there&rsquo;s more going on under the hood, and
indeed, this is in fact the 3D engine <a href=https://unity3d.com/>Unity</a> in action,
as evidenced by this <a href=https://unity3d.com/showcase/case-stories/cardboardcomputer-kentuckyroutezero>featured
article</a>.</p><figure class=image><a class=largeimg href=/2016/04/28/the-nim-ray-tracer-project-part-1-introduction/img/krz.jpg data-pswp-width=1920 data-pswp-height=1080><img src=/2016/04/28/the-nim-ray-tracer-project-part-1-introduction/img/krz.jpg alt="Kentucky Road Zero, Act I in-game screenshot" style=width:100% loading=lazy></a><figcaption style=width:100%>The opening scene of <a href=http://kentuckyroutezero.com>Kentucky Route Zero</a>,
Act I by <a href=http://cardboardcomputer.com>Cardboard Computer</a>. If David Lynch
ever ventured into making a computer game, then this would be it. The unique
visual style of the game proves that an unconventional, abstract approach to
rendering instead of taking the well-beaten &ldquo;standard&rdquo; photorealistic path
can yield much more interesting results."</figcaption></figure><p><a href=https://www.theastronauts.com/>The Astronauts</a>' first-person mystery game
<a href=https://en.wikipedia.org/wiki/The_Vanishing_of_Ethan_Carter>The Vanishing of Ethan Carter</a>, on the other
hand, employs a breathtakingly beautiful painterly approach to create its
immersive in-game atmosphere. As it can be clearly seen on the screenshot, the
results are stunningly realistic, but in a dreamy and artistic kind of way
which is not dissimilar at all to the Caravaggio painting presented above. The
developers used a technique called
<a href=https://www.theastronauts.com/2014/03/visual-revolution-vanishing-ethan-carter/>photogrammetery</a>
to effectively sample reality in the form of textures and 3D meshes from
thousands of photographs, but from there on it&rsquo;s all traditional rasterization
using the <a href=https://www.unrealengine.com/>Unreal Engine</a>.</p><figure class=image><a class=largeimg href=/2016/04/28/the-nim-ray-tracer-project-part-1-introduction/img/ethan-carter.jpg data-pswp-width=1920 data-pswp-height=1080><img src=/2016/04/28/the-nim-ray-tracer-project-part-1-introduction/img/ethan-carter.jpg alt="The Vanishing of Ethan Carter in-game screenshot" style=width:100% loading=lazy></a><figcaption style=width:100%>One of the most beautiful games of recent years, <a href=https://en.wikipedia.org/wiki/The_Vanishing_of_Ethan_Carter>The Vanishing of Ethan
Carter</a> pulls
the player in into its highly realistic yet painterly world right from the
first second of gameplay. No trace (pun intended) of physical based
rendering is to be found here, yet the results speak for themselves.</figcaption></figure><p>I suspect it would have been quite difficult to achieve the same level of
painterly feel by employing a strict ray tracing approach, even if that was
possible at fluid frame rates on current hardware at all. While ray tracing
would have certainly yielded a more faithful portrayal of reality in terms of
sheer physical accuracy, it could not have granted the artist as much creative
freedom to sculpt the games&rsquo;s almost otherwordly beautiful scenes by freely
manipulating the shades and colours. Atmosphere and emotions beat pure
physics in this example again.</p><h2 id=why-nim>Why Nim?</h2><p>You know the old saying, mastering a programming language just by reading
about it is like trying to learn how to ride the bicycle from a book. I get
quickly bored by solving toy textbook exercises too; implementing quicksort in
yet another language is not quite my idea of having a good time, really. What
works for me best is writing a new application from scratch that does some
cool stuff that I&rsquo;m excited about and learn the new language along the way. So
that&rsquo;s what we&rsquo;re gonna do here, write a full-featured ray tracer from the
ground up in pure Nim!</p><p>Oh, and why <a href=https://nim-lang.org/>Nim</a>? Serious peopleâ„¢ use C++ for
high-performance graphics stuff, don&rsquo;t they? Well, this is going to be a ray
tracer, so speed matters <em>a lot</em>, indeed&mdash;but so does the fun factor and my
sanity too, as I&rsquo;m not paid to suffer here, this being a hobby project and all
(on a related note, don&rsquo;t be a masochist, <a href=/2016/03/03/the-quest-for-a-programming-language-that-doesnt-suck-part-1/>just say No to
C++!</a>).
Nim claims to be &ldquo;Efficient like C, expressive like Python and flexible like
Lisp&rdquo; which sounds pretty good in my book. In fact, C, Python and Lisp are
probably my three all-time favourite languages, so this actually sounds more
like a dream come true! So what we&rsquo;re gonna do here is take this little guy
for a wild ride and see how it lives up to its lofty goals in the real world!</p><h2 id=in-the-next-episode>In the next episode&mldr;</h2><p>We will examine the mathematical foundations of writing a simple ray tracer.
Time to brush up those high-school trigonometry skills! Stay tuned!</p><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>To put things into perspective, my experimentations with ray tracing
on the Amiga took place in around 1992. There was virtually no Internet back
then, I haven&rsquo;t even heard the word until several years later. I read it in
a <em>paper computer magazine</em> (yes, those things <em>did</em> actually exist, can you
believe it?) that the CGI effects in the 1991 film
<a href=https://en.wikipedia.org/wiki/Terminator_2:_Judgment_Day>Terminator 2: Judgement Day</a>
were rendered on a room full of ultra high-end (and ultra-expensive)
<a href=http://www.sgistuff.net/hardware/systems/iris3000.html>Silicon Graphics IRIS</a>
<a href=http://www.sgistuff.net/funstuff/hollywood/>workstations</a>, but even with
that kind of computing power it took <em>several months</em> to render a few
minutes' worth of scenes. Now, seeing <em>any kind of</em> semi-photorealistic ray
traced image come out of my modest
<a href=https://en.wikipedia.org/wiki/Amiga_500>Amiga 500</a> personal computer setup
sporting a blazingly fast 7.14 Mhz
<a href=https://en.wikipedia.org/wiki/Motorola_68000>Motorola 68000 CPU</a>
seemed nothing short of a small miracle to me then! (Actually, that chip is as
old as <em>yours truly</em>, I&rsquo;ve just checked&mldr;) Oh, and I had no such luxuries as
a <em>hard disk drive</em> either&mdash;the whole program and the scene to be rendered
had to fit into the machine&rsquo;s whopping 1 MB of RAM (expanded from the 512 KB
factory default) and the final image was then slowly written to a blank
<a href=https://en.wikipedia.org/wiki/Floppy_disk_variants#Commodore_Amiga>880 KB floppy disk</a>
over the course of 7-8 hours! Eh, kids these days with their GPU-accelerated
Monte Carlo path tracers&mldr;&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section><section class=comments><h2>Comments</h2><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//johnnovak.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></article></div></div></body><script type=module>
    import PhotoSwipeLightbox from '/js/lib/photoswipe-lightbox.esm.min.js';

    const lightbox = new PhotoSwipeLightbox({
      gallery: 'body',
      children: 'figure > a',
      showHideAnimationType: 'none',
      pswpModule: () => import('/js/lib/photoswipe.esm.min.js')
    });

    lightbox.init();
  </script></html>