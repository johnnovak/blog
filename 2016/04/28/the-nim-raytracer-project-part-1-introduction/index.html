<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.2.0">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width; target-densityDpi=160; initial-scale=1; maximum-scale=1">
  <meta name="description" content="Personal blog of John Novak">
  <meta name="author" content="John Novak">
  <meta name="Generator" content="Jekyll (https://jekyllrb.com/)">
  <title>The Nim Ray Tracer Project – Part 1: Introduction</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=UnifrakturMaguntia">
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700,400italic,700italic"><!--Source Sans Pro is required for the SVG images only -->
  <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Astloch">
  <link rel="stylesheet" type="text/css" href="https://blog.johnnovak.net/css/blog.css">
  <link rel="stylesheet" type="text/css" href="https://blog.johnnovak.net/css/jqmath-0.4.6.css">
  <link rel="stylesheet" type="text/css" href="https://blog.johnnovak.net/css/photoswipe.css">
  <link rel="stylesheet" type="text/css" href="https://blog.johnnovak.net/css/photoswipe-default-skin/default-skin.css">
  <script src="https://blog.johnnovak.net/js/lib/modernizr.min.js" charset="utf-8">
  </script>
  <script src="https://blog.johnnovak.net/js/lib/jquery-1.12.4.min.js" charset="utf-8">
  </script>
  <script src="https://blog.johnnovak.net/js/lib/jqmath-etc-0.4.6.min.js" charset="utf-8">
  </script>
  <script src="https://blog.johnnovak.net/js/lib/photoswipe.min.js" charset="utf-8">
  </script>
  <script src="https://blog.johnnovak.net/js/lib/photoswipe-ui-default.min.js" charset="utf-8">
  </script>
  <script src="https://blog.johnnovak.net/js/blog.js" charset="utf-8">
  </script><!-- <script>M.MathPlayer = false; M.trustHtml = true;</script> -->
  <link rel="alternate" type="application/rss+xml" title="Personal blog of John Novak" href="https://blog.johnnovak.net/feed.xml">
</head>
<body>
  <script src="https://blog.johnnovak.net/js/lib/respond.min.js">
  </script>
  <div id="wrapper">
    <header id="header">
      <div id="header-bg"></div><a href="https://blog.johnnovak.net"><img id="jn-logo" src="https://blog.johnnovak.net/img/jn-logo.png" alt="John Novak" data-2x="https://blog.johnnovak.net/img/jn-logo@2x.png"></a>
      <p class="tagline">Riding on the tail of the<br>
      Gaussian curve<br>
      since 1979</p>
      <nav>
        <ul>
          <li>
            <a href="https://blog.johnnovak.net/about/">About</a>
          </li>
          <li>
            <a href="https://blog.johnnovak.net/archives/">Archives</a>
          </li>
          <li>
            <a href="https://blog.johnnovak.net/tags/">Tags</a>
          </li>
          <li class="last">
            <a href="https://blog.johnnovak.net/feed.xml">Rss</a>
          </li>
        </ul>
      </nav>
    </header>
    <div role="main">
      <article class="post">
        <header>
          <h1><a href="/2016/04/28/the-nim-raytracer-project-part-1-introduction/">The Nim Ray Tracer Project – Part 1: Introduction</a></h1>
          <p class="date"><time datetime="2016-04-28">2016 Apr 28</time></p>
        </header>
        <nav class="tags">
          <ul>
            <li>
              <a href="/tag/graphics/">graphics</a>
            </li>
            <li>
              <a href="/tag/ray%20tracing/">ray tracing</a>
            </li>
            <li>
              <a href="/tag/nim/">nim</a>
            </li>
          </ul>
        </nav>
        <p class="intro">[Listening to the albums <em>Reverberant Skies</em> and <em>White Maps</em> from <em>Aglaia</em> in an infinite loop… A beautifully hypnotic experience! The track <em>In the First Spinning Place</em> from <em>White Maps</em> is my absolute favourite.]</p>
        <h2 id="why-a-ray-tracer">Why a ray tracer?</h2>
        <p>I’ve been fascinated by ray tracing since my childhood. I still remember the first time I was playing around with an early 3D modeller/ray tracer program on the <a href="https://en.wikipedia.org/wiki/Amiga_500">Amiga 500</a> called <a href="https://en.wikipedia.org/wiki/Imagine_%283D_modeling_software%29">Imagine</a> when I was about 13, trying to render some extruded letters made of glass placed on a classic checker-board patterned surface (don’t laugh, this was sort of a novel thing to do at that time, and I was a kid). Well, rendering the final 360x576 image (<a href="https://en.wikipedia.org/wiki/Overscan%3E">overscan</a>!) took a bit more than 7 hours, but when I turned on the monitor in the morning in great anticipation and saw the final image in its <a href="https://en.wikipedia.org/wiki/Hold-And-Modify">4096-colour</a> interlaced glory (probably quite primitive looking by today’s standards), I was in awe! What made the experience even more interesting for me was
        that Imagine supported the use of so-called procedural textures, which are textures solely generated by mathematical functions instead of using bitmap images. I was mesmerised—a photorealistic image generated by the computer using nothing else but pure maths! <sup id="fnref:amiga"><a href="#fn:amiga" class="footnote">1</a></sup></p>
        <p>I have always thought of ray tracing as some kind of black magic—something utterly fascinating and very scary at the same time because of the complex maths involved (which, as it turns out, is not quite true). This belief was also strengthened by my modest excursions into OpenGL programming years later, which uses a different method called <a href="https://en.wikipedia.org/wiki/Rasterisation">rasterization</a> to generate 3D images.</p>
        <h2 id="ray-tracing-vs-rasterization">Ray tracing vs rasterization</h2>
        <p>Historically, there have been two main disparate approaches to rendering 3D scenes, rasterization and ray tracing (the situation is not so clear-cut nowadays, as we’ll see later). While rasterization is by several orders of magnitude more efficient at producing 3D animations at smooth frame rates in real-time, ray tracing can produce vastly more photorealistic results. While many visual effects that happen in real life, such as non-planar reflections, soft shadows, refractions and caustics, are quite simple, albeit computationally very costly, to calculate with ray tracing, it requires quite a bit of complicated trickery even just to fake them with rasterization.</p>
        <p>At the risk of grossly oversimplifying matters, rasterization is very efficient at projecting several hundreds of thousands of three-dimensional triangles onto a two-dimensional surface (the screen) and then colouring (shading) them according to some rules. In order to obtain reasonable frame rates during real-time animation, certain simplifications and optimisations have to be made. Photorealistic rendering that accurately portrays how a given scene would look in real life is not necessarily of primary importance as long as the end result looks pleasing (which is a reasonable assumption for many applications such as visualisation and games, where absolute fidelity to reality is not a requirement). It’s the 3D artists’ job to arrange those coloured triangles so that the resulting image looks good. Most graphics-accelerator cards today implement some sort of rasterization pipeline in hardware.</p>
        <p><a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">Ray tracing</a>, on the other hand, is a pretty much a no-holds-barred approach of generating realistic images on a computer by simulating the path of photons emitted by light sources bouncing from surface to surface among the objects making up the 3D scene, finally landing on the image surface of the virtual camera. Photorealism is of primary importance here, which is achieved by calculating the image pixel by pixel using algorithms that mimic the laws of physics as closely as practically possible (certain simplifications must be made, of course, otherwise we would end up writing a Universe Simulator!).</p>
        <p>This begs the question, is ray tracing superior to rasterization then? In some way, we can say it is. As far as photorealistic rendering is concerned, ray tracing is hard to beat, however this comes at a very steep computational cost. But if we asked whether it was possible to create pleasing imagery using rasterization alone, the answer would be a yes again. Just because rasterization is not as much rooted in physical reality as ray tracing, it would be foolish to think that it’s not capable of producing stellar results that can look very convincingly real (just look at any modern game released post 2010!). Indeed, there’s nothing preventing skilful artists from arranging the triangles making up the scene in such a way that can convey very realistic final results—similarly to how a master painter can create astonishingly realistic works of art by nothing more than applying differently coloured specks of paint onto a canvas with a mere paintbrush.</p>
        <figure class="image">
          <a class="largeimg" href="/files/2016-04-28/caravaggio.jpg" data-width="800" data-height="822"><img src="/files/2016-04-28/caravaggio.jpg" alt="Caravaggio, The Calling of St Matthew" style="width: 80%"></a>
          <figcaption style=" width: 80%;">
            Surely, <a href="https://en.wikipedia.org/wiki/Caravaggio">Caravaggio</a> did not know about the <a href="https://en.wikipedia.org/wiki/Fresnel_equations">Fresnel equations</a> or the <a href="https://en.wikipedia.org/wiki/Metropolis_light_transport">Metropolis light transport</a> when he painted <a href="https://en.wikipedia.org/wiki/The_Calling_of_St_Matthew_(Caravaggio)">The Calling of Saint Matthew</a> in 1600. Yet no one would say his paintings are not realistic enough just because he did not know about the physics of light! Interestingly enough, there have been some <a href="http://www.webexhibits.org/hockneyoptics/post/grundy7.html">speculations</a> that he might have used the <a href="https://en.wikipedia.org/wiki/Camera_obscura">camera obscura</a> to aid him in attaining his photorealistic results, the workings of which have strong connections to the basic idea of ray tracing. Here we go!
          </figcaption>
        </figure>
        <p>As CPUs and GPUs grew more powerful, previously purely rasterization-based game engines have been increasingly incorporating ray tracing techniques into their toolbox, such as <a href="http://blogs.unity3d.com/2014/09/18/global-illumination-in-unity-5/">global illumination</a>, <a href="http://twiik.net/articles/realtime-reflections-in-unity-5">real-time reflections</a> and <a href="https://vimeo.com/82659909">pseudo-refraction</a> using shaders. These techniques are usually quite limited compared to their ray tracing counterparts, for example global illumination is usually restricted to static objects, reflections are only possible on planar surfaces and refraction is faked with shaders.</p>
        <p>Also, more and more game engines have started implementing <a href="http://blog.wolfire.com/2015/10/Physically-based-rendering">physically-based rendering (PBR)</a> methods recently, the renowned <a href="https://en.wikipedia.org/wiki/CryEngine">CryEngine</a> being one notable example. The following is the introductory paragraph of the <a href="http://docs.cryengine.com/display/SDKDOC2/Physically+Based+Shading">Physically Based Shading</a> chapter of the <a href="http://docs.cryengine.com/display/SDKDOC1/Home">CryEngine SDK documentation</a>:</p>
        <blockquote>
          <p>CRYENGINE 3.6 and beyond uses a shading model that is based on fundamental physical rules. Instead of using a plenty of fudge and tweak factors which don’t have a reasonable meaning in the real world, materials use some physical properties to describe how the incoming light should interact with them. A huge advantage of using a physically based model with certain rules is that material assets will a lot more consistent and look more convincing under different lighting conditions.</p>
        </blockquote>
        <p>This supports my earlier claim that while it’s certainly possible to create realistic visuals with rasterization, photorealism is not inherent in the rendering algorithm, but requires manual tweaking and fine-tuning of various parameters on the part of the 3D artist.</p>
        <p>To sum up, I personally tend to think of rasterization as a more artist-centric and ray tracing as a more scientific approach of image generation. Ultimately, both are just tools of solving the problem of mapping a 3D scene onto a 2D image surface, but there’s a certain undeniable beauty and elegance to ray tracing algorithms in how they generate complex visual and optical effects by the application of just a few simplified physical models of reality.</p>
        <h3 id="in-defence-of-rasterization">In defence of rasterization</h3>
        <p>Just to bring the point home that rasterization is not inferior to ray tracing but only different, and to further support my argument that it is a more artist-based approach to rendering, let me present two examples from the two opposite ends of the spectrum of what rasterization is capable of. As we’ll see, it would have been difficult or impractical (or both) to achieve the same results with pure ray tracing techniques alone in both cases.</p>
        <p>The magical realist adventure game (whatever that means) <a href="http://kentuckyroutezero.com/">Kentucky Road Zero</a> by the aptly titled developer <a href="http://cardboardcomputer.com/">Cardboard Computer</a> uses clever rasterization tricks to render its highly stylised low-polygon world. While the abstract visuals bear similitude to simple 2D paper cut-outs in most scenes, some occasional camera angle switches hint at it that there’s more going on under the hood, and indeed, this is in fact the 3D engine <a href="https://unity3d.com/">Unity</a> in action, as evidenced by this <a href="https://unity3d.com/showcase/case-stories/cardboardcomputer-kentuckyroutezero">featured article</a>.</p>
        <figure class="image">
          <a class="largeimg" href="/files/2016-04-28/krz.jpg" data-width="1920" data-height="1080"><img src="/files/2016-04-28/krz.jpg" alt="Kentucky Road Zero, Act I in-game screenshot" style="width: 100%"></a>
          <figcaption style=" width: 100%;">
            The opening scene of <a href="http://kentuckyroutezero.com/">Kentucky Road Zero</a>, Act I by <a href="http://cardboardcomputer.com/">Cardboard Computer</a>. If David Lynch ever ventured into making a computer game, then this would be it. The unique visual style of the game proves that an unconventional, abstract approach to rendering instead of taking the well-beaten "standard" photorealistic path can yield much more interesting results.
          </figcaption>
        </figure>
        <p><a href="http://www.theastronauts.com/">The Astronauts</a>’ first-person mystery game <a href="http://ethancartergame.com/">The Vanishing of Ethan Carter</a>, on the other hand, employs a breathtakingly beautiful painterly approach to create its immersive in-game atmosphere. As it can be clearly seen on the screenshot, the results are stunningly realistic, but in a dreamy and artistic kind of way which is not dissimilar at all to the Caravaggio painting presented above. The developers used a technique called <a href="http://www.theastronauts.com/2014/03/visual-revolution-vanishing-ethan-carter/">photogrammetery</a> to effectively sample reality in the form of textures and 3D meshes from thousands of photographs, but from there on it’s all traditional rasterization using the <a href="https://www.unrealengine.com/">Unreal Engine</a>.</p>
        <figure class="image">
          <a class="largeimg" href="/files/2016-04-28/ethan-carter.jpg" data-width="1920" data-height="1080"><img src="/files/2016-04-28/ethan-carter.jpg" alt="The Vanishing of Ethan Carter in-game screenshot" style="width: 100%"></a>
          <figcaption style=" width: 100%;">
            One of the most beautiful games of recent years, <a href="http://ethancartergame.com/">The Vanishing of Ethan Carter</a> pulls the player in into its highly realistic yet painterly world right from the first second of gameplay. No trace (pun intended) of physical based rendering is to be found here, yet the results speak for themselves.
          </figcaption>
        </figure>
        <p>I suspect it would have been quite difficult to achieve the same level of painterly feel by employing a strict ray tracing approach, even if that was possible at fluid frame rates on current hardware at all. While ray tracing would have certainly yielded a more faithful portrayal of reality in terms of sheer physical accuracy, it could not have granted the artist as much creative freedom to sculpt the games’s almost otherwordly beautiful scenes by freely manipulating the shades and colours. Atmosphere and emotions beat pure physics in this example again.</p>
        <h2 id="why-nim">Why Nim?</h2>
        <p>You know the old saying, mastering a programming language just by reading about it is like trying to learn how to ride the bicycle from a book. I get quickly bored by solving toy textbook exercises too; implementing quicksort in yet another language is not quite my idea of having a good time, really. What works for me best is writing a new application from scratch that does some cool stuff that I’m excited about and learn the new language along the way. So that’s what we’re gonna do here, write a full-featured ray tracer from the ground up in pure Nim!</p>
        <p>Oh, and why <a href="http://nim-lang.org/">Nim</a>? Serious people™ use C++ for high-performance graphics stuff, don’t they? Well, this is going to be a ray tracer, so speed matters <em>a lot</em>, indeed—but so does the fun factor and my sanity too, as I’m not paid to suffer here, this being a hobby project and all (on a related note, don’t be a masochist, <a href="/2016/03/03/the-quest-for-a-programming-language-that-doesnt-suck-part1/">just say No to C++!</a>). Nim claims to be “Efficient like C, expressive like Python and flexible like Lisp” which sounds pretty good in my book. In fact, C, Python and Lisp are probably my three all-time favourite languages, so this actually sounds more like a dream come true! So what we’re gonna do here is take this little guy for a wild ride and see how it lives up to its lofty goals in the real world!</p>
        <h2 id="in-the-next-episode">In the next episode…</h2>
        <p>We will examine the mathematical foundations of writing a simple ray tracer. Time to brush up those high-school trigonometry skills! Stay tuned!</p>
        <div class="footnotes">
          <ol>
            <li id="fn:amiga">
              <p>To put things into perspective, my experimentations with ray tracing on the Amiga took place in around 1992. There was virtually no Internet back then, I haven’t even heard the word until several years later. I read it in a <em>paper computer magazine</em> (yes, those things <em>did</em> actually exist, can you believe it?) that the CGI effects in the 1991 film <a href="https://en.wikipedia.org/wiki/Terminator_2:_Judgment_Day">Terminator 2: Judgement Day</a> were rendered on a room full of ultra high-end (and ultra-expensive) <a href="http://www.obsolyte.com/sgi_iris/">Silicon Graphics IRIS</a> <a href="http://www.sgistuff.net/funstuff/hollywood/">workstations</a>, but even with that kind of computing power it took <em>several months</em> to render a few minutes’ worth of scenes. Now, seeing <em>any kind of</em> semi-photorealistic ray traced image come out of my modest <a href="https://en.wikipedia.org/wiki/Amiga_500">Amiga 500</a> personal computer setup sporting a
              blazingly fast 7.14 Mhz <a href="https://en.wikipedia.org/wiki/Motorola_68000">Motorola 68000 CPU</a> seemed nothing short of a small miracle to me then! (Actually, that chip is as old as <em>yours truly</em>, I’ve just checked…) Oh, and I had no such luxuries as a <em>hard disk drive</em> either—the whole program and the scene to be rendered had to fit into the machine’s whopping 1 MB of RAM (expanded from the 512 KB factory default) and the final image was then slowly written to a blank <a href="https://en.wikipedia.org/wiki/Floppy_disk_variants#Commodore_Amiga">880 KB floppy disk</a> over the course of 7-8 hours! Eh, kids these days with their GPU-accelerated Monte Carlo path tracers… <a href="#fnref:amiga" class="reversefootnote">↩</a></p>
            </li>
          </ol>
        </div>
        <section class="comments">
          <h2>Comments</h2><noscript>
          <p id="no-disqus"><i>Please enable JavaScript to view the comments.</i></p></noscript>
          <div id="disqus_thread"></div>
          <script type="text/javascript">
          var disqus_shortname = "johnnovak";
          var disqus_identifier = "/2016/04/28/the-nim-raytracer-project-part-1-introduction/";
          var disqus_title = "The Nim Ray Tracer Project &ndash; Part 1: Introduction";
          var disqus_url = "https://blog.johnnovak.net//2016/04/28/the-nim-raytracer-project-part-1-introduction/";

          (function() {
          var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
          </script>
        </section>
      </article>
    </div>
  </div>
</body>
</html>
