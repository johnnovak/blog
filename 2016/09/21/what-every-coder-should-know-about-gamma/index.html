<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width;target-densityDpi=160;initial-scale=1;maximum-scale=1"><meta name=description content="Personal blog of John Novak"><meta name=author content="John Novak"><title>What every coder should know about gamma | John Novak</title><link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;1,400;1,600;1,700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Inconsolata:400,700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600,700&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Astloch&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=UnifrakturMaguntia&display=swap" rel=stylesheet><link rel=stylesheet href=https://blog.johnnovak.net/sass/blog.63b8160b4504b230d467bd1075e9672bc173d8b232a6f866511ba65db1ef15dc.css type=text/css><link rel=stylesheet href=/css/jqmath-0.4.3.css type=text/css><link rel=stylesheet href=/css/photoswipe.css type=text/css><script src=/js/lib/jquery-1.12.4.min.js></script><script src=/js/lib/jqmath-etc-0.4.6.min.js></script><script src=/js/blog.js></script><link rel=alternate type=application/rss+xml title="Recent posts" href=https://blog.johnnovak.net/index.xml></head><body><div id=wrapper><header id=header><div id=header-bg></div><a href=/><img id=jn-logo src=/img/jn-logo.png alt="John Novak" data-2x=/img/jn-logo@2x.png></a><p class=tagline>Riding on the tail of the<br>Gaussian curve<br>since 1979</p><nav><ul><li><a href=/about/>About</a></li><li><a href=/posts/>Posts</a></li><li class=last><a href=/tags/>Tags</a></li></ul></nav></header><div role=main><article class=post><header><h1><a href=/2016/09/21/what-every-coder-should-know-about-gamma/>What every coder should know about gamma</a></h1><p class=date><time datetime=2016-09-21>2016 Sep 21</time></p></header><nav class=tags><ul><li><a href=/tags/graphics/>graphics</a></li><li><a href=/tags/gamma/>gamma</a></li><li><a href=/tags/linear-workflow/>linear workflow</a></li></ul></nav><h2>Table of contents</h2><nav id=TableOfContents><ul><li><a href=#a-short-quiz>A short quiz</a></li><li><a href=#the-arcane-art-of-gamma-correctness>The arcane art of gamma-correctness</a></li><li><a href=#what-is-gamma-and-why-do-we-need-it>What is gamma and why do we need it?</a><ul><li><a href=#light-emission-vs-perceptual-brightness>Light emission vs perceptual brightness</a></li><li><a href=#physical-vs-perceptual-linearity>Physical vs perceptual linearity</a></li><li><a href=#efficient-image-encoding>Efficient image encoding</a></li><li><a href=#the-gamma-transfer-function>The gamma transfer function</a></li><li><a href=#gamma-vs-srgb>Gamma vs sRGB</a></li><li><a href=#gamma-calibration>Gamma calibration</a></li><li><a href=#processing-gamma-encoded-images>Processing gamma-encoded images</a></li></ul></li><li><a href=#effects-of-gamma-incorrectness>Effects of gamma-incorrectness</a><ul><li><a href=#gradients>Gradients</a></li><li><a href=#colour-blending>Colour blending</a></li><li><a href=#alpha-blending--compositing>Alpha blending / compositing</a></li><li><a href=#image-resizing>Image resizing</a></li><li><a href=#antialiasing>Antialiasing</a></li><li><a href=#physically-based-rendering>Physically-based rendering</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references--further-reading>References & further reading</a><ul><li><a href=#general-gammasrgb-info>General gamma/sRGB info</a></li><li><a href=#linear-lighting--workflow-lwf>Linear lighting & workflow (LWF)</a></li><li><a href=#bonus-stuff>Bonus stuff</a></li></ul></li></ul></nav><h2 id=a-short-quiz>A short quiz</h2><p>If you have ever written, or are planning to write, <em>any kind of code</em> that
deals with image processing, you should complete the below quiz. If you have answered
one or more questions with a yes, there&rsquo;s a high chance that your code is
doing the wrong thing and will produce incorrect results. This might not be
immediately obvious to you because these issues can be subtle and they&rsquo;re
easier to spot in some problem domains than in others.</p><p>So here&rsquo;s the quiz:</p><ul><li>I don&rsquo;t know what gamma correction is (duh!)</li><li>Gamma is a relic from the CRT display era; now that almost everyone uses
LCDs, it&rsquo;s safe to ignore it.</li><li>Gamma is only relevant for graphics professionals working in the print
industry where accurate colour reproduction is of great
importance&mdash;for general image processing, it&rsquo;s safe to ignore it.</li><li>I&rsquo;m a game developer, I don&rsquo;t need to know about gamma.</li><li>The graphics libraries of my operating system handle gamma correctly.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li><li>The popular graphics library <em>&lt;insert name here></em> I&rsquo;m using handles
gamma correctly.</li><li>Pixels with RGB values of (128, 128, 128) emit about half as much light as
pixels with RGB values of (255, 255, 255).</li><li>It is okay to just load pixel data from a popular image format (JPEG, PNG,
GIF etc.) into a buffer using some random library and run image processing
algorithms on the raw data directly.</li></ul><p>Don&rsquo;t feel bad if you have answered most with a yes! I would have given
a yes to most of these questions a week ago myself too. Somehow, the topic
of gamma is just under most computer users' radar (including programmers
writing commercial graphics software!), to the extent that most graphics
libraries, image viewers, photo editors and drawing software of today still
don&rsquo;t get gamma right and produce incorrect results.</p><p>So keep on reading, and by the end of this article you&rsquo;ll be more
knowledgeable about gamma than the vast majority of programmers!</p><h2 id=the-arcane-art-of-gamma-correctness>The arcane art of gamma-correctness</h2><p>Given that vision is arguably the most important sensory input channel for
human-computer interaction, it is quite surprising that gamma correction is
one of the least talked about subjects among programmers and it&rsquo;s mentioned in
technical literature rather infrequently, <em>including</em> computer graphics texts.
The fact that most computer graphics textbooks don&rsquo;t explicitly mention the
importance of correct gamma handling, or discuss it in practical terms, does
not help matters at all (my <a href=https://sirkan.iit.bme.hu/~szirmay/szamgraf.html>CG textbook from
uni</a> falls squarely into
this category, I&rsquo;ve just checked). Some books mention gamma correction in
passing in somewhat vague and abstract terms, but then provide neither
concrete real-world examples on how to do it properly, nor explain what the
implications of not doing it properly are, nor show image examples of
incorrect gamma handling.</p><p>I came across the need for correct gamma handling during writing my <a href=/tags/ray-tracing/>ray
tracer</a> and I had to admit that my understanding of the
topic was rather superficial and incomplete. So I had spent a few days reading
up on it online, but it turned out that many articles about gamma are not much
help either, as many of them are too abstract and confusing, some contain too
many interesting but otherwise irrelevant details, and then some others lack
image examples or are just simply incorrect or hard to understand. Gamma is
not a terribly difficult concept to begin with, but for some mysterious reason
it&rsquo;s not that trivial to find articles on it that are correct, complete and
explain the topic in a clear language.</p><h2 id=what-is-gamma-and-why-do-we-need-it>What is gamma and why do we need it?</h2><p>Alright, so this is my attempt to offer a comprehensive explanation of gamma,
focusing just on the most important aspects and assuming no prior knowledge of
it.</p><p>The image examples in this article assume that you are viewing this web page in
a modern browser on a computer monitor (CRT or LCD, doesn&rsquo;t matter). Tablets
and phones are generally quite inaccurate compared to monitors, so try to
avoid those. You should be viewing the images in a dimly lit room, so no
direct lights or flare on your screen please.</p><h3 id=light-emission-vs-perceptual-brightness>Light emission vs perceptual brightness</h3><p>Believe it or not, the difference of <strong>light energy emission</strong> between any two
neighbouring vertical bars in the below image is a <em>constant</em>. In other words,
the amount of light energy emitted by your screen increases by a <em>constant
amount</em> from bar to bar, left to right.</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/linear-ramp32.png alt="Figure 1 &mdash; Evenly-spaced greyscale bars in terms of emitted light intensity" style=width:100% loading=lazy><figcaption style=width:100%;text-align:center>Figure 1 &mdash; Evenly-spaced greyscale bars in terms of emitted light
intensity (<a href=src/gammaramp.nim>Nim source code</a>)</figcaption></figure><p>Now consider the following image:</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/gamma-ramp32.png alt="Figure 2 &mdash; Evenly-spaced greyscale bars in terms of perceptual light intensity" style=width:100% loading=lazy><figcaption style=width:100%;text-align:center>Figure 2 &mdash; Evenly-spaced greyscale bars in terms of perceptual light
intensity (<a href=src/gammaramp.nim>Nim source code</a>)</figcaption></figure><p>On which image does the gradation appear more even? It&rsquo;s the second one! But
why is that so? We have just established that in the first image the bars are
evenly (<em>linearly</em>) spaced in terms of emitted light intensity between the
darkest black and brightest white your monitor is capable of reproducing. But
why don&rsquo;t we see that as a nice even gradation from black to white then? And
what is being displayed on the second image that we <em>perceive</em> as a linear
gradation?</p><p>The answer lies in the response of the human eye to light intensity, which is
<em>non-linear</em>. One the first image, the <strong>difference</strong> between the nominal light
intensity of any two neighbouring bars is constant:</p><p>$$\Δ_{\linear} = I_n-I_{n-1}$$</p><p>On the second image, however, this difference is not constant but changes from
bar to bar; it follows a power law relationship, to be exact. All human
sensory perception follows a similar <a href="https://en.wikipedia.org/wiki/Stevens'_power_law">power law
relationship</a> in terms of
the magnitude of stimulus and its perceived intensity.</p><p class=important>Because of this, we say that there is a <strong>power law relationship</strong> between
<strong>nominal physical light intensity</strong> and <strong>perceptual brightness</strong>.</p><h3 id=physical-vs-perceptual-linearity>Physical vs perceptual linearity</h3><p>Let&rsquo;s say we wanted to store a representation of the following real-world
object as an image file on the computer (let&rsquo;s pretend for a moment
that perfect greyscale gradients exist in the real world, okay?) Here&rsquo;s how
the &ldquo;real world object&rdquo; looks like:</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/linear-ramp.png alt="Figure 3 &mdash; Ideal smooth greyscale ramp" style=width:100% loading=lazy><figcaption style=width:100%;text-align:center>Figure 3 &mdash; Ideal smooth greyscale ramp
(<a href=src/gammaramp.nim>Nim source code</a>)</figcaption></figure><p>Now, let&rsquo;s pretend that we can only store 5-bit greyscale images on this
particular computer system, which gives us 32 distinct shades of grey ranging
from absolute black to absolute white. Also, on this computer, greyscale
values are <em>proportional</em> with their corresponding physical light intensities,
which will result in a 32-element greyscale as shown on Figure 1. We can say
that this greyscale is <em>linear</em> in terms of <em>light emission</em> between
successive values.</p><p>If we encoded our smooth gradient using only these 32 grey values, we would get
something like this (let&rsquo;s just ignore dither for now to keep things simple):</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/linear-ramp32-perceptual.png alt="Figure 4 &mdash; Ideal smooth greyscale ramp represented with 32 physically-linear greyscale values" style=width:100% loading=lazy><figcaption style=width:100%;text-align:center>Figure 4 &mdash; Ideal smooth greyscale ramp represented with 32
physically-linear greyscale values (<a href=src/gammaramp.nim>Nim source code</a>)</figcaption></figure><p>Well, the transitions are rather abrupt, especially on the left side, because
we only had 32 grey values to work with. If we squint a little, it&rsquo;s easy to
convince ourselves that this is a more or less &ldquo;accurate&rdquo; representation of
the smooth gradient, as far as our limited bit-depth allows it. But note how
the steps are much larger on the left side than on the right&mdash;this is because
we are using a greyscale that is <em>linear</em> in terms of <em>emitted light
intensity</em>, but as we have mentioned before, our eyes don&rsquo;t perceive light
intensity in a linear way!</p><p>This observation has some interesting implications. The error between the
original and the 5-bit encoded version is uneven across the image; it&rsquo;s much
larger for dark values than for light ones. In other words, we are losing
representational precision for dark values and are using relatively too much
precision for lighter shades. Clearly, we&rsquo;d be better off choosing
a different set of 32 greys for our limited palette of shades that would make
this error evenly distributed across the whole range, so both dark and light
shades would be represented with the same precision. If we encoded our
original image with such a greyscale that is <em>perceptually linear</em>, but
consequently <em>non-linear</em> in terms of emitted light intensity, and that
non-linearity would match that of the human vision, we&rsquo;d get the exact same
greyscale image we have already seen in Figure 2:</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/gamma-ramp32.png alt="Figure 5 &mdash; Ideal smooth greyscale represented with 32 perceptually-linear greyscale values" style=width:100% loading=lazy><figcaption style=width:100%>Figure 5 &mdash; Ideal smooth greyscale represented with 32 perceptually-linear
greyscale values (<a href=src/gammaramp.nim>Nim source code</a>)</figcaption></figure><p class=important>The non-linearity we&rsquo;re talking about here is the <strong>power law</strong> relationship
we mentioned before, and the non-linear transformation we need to apply to
our <em>physically linear</em> greyscale values to transform them into
<em>perceptually linear</em> values is called <strong>gamma correction</strong>.</p><h3 id=efficient-image-encoding>Efficient image encoding</h3><p>Why is the all the above important? Colour data in so-called &ldquo;true colour&rdquo; or
&ldquo;24-bit&rdquo; bitmap images is stored as three 8-bit integers per pixel. With
8 bits, 256 distinct intensity levels can be represented, and if the spacing
of these levels were physically linear, we would be losing a lot of precision
on dark shades while being unnecessarily precise on light shades (relatively
speaking), as shown above.</p><p>Clearly, this is not ideal. One solution would be to simply keep using the
physically linear scale and increase the bit depth per channel to 16 (or
more). This would double the storage requirements (or worse), which was not
an option when most common image formats were invented. Therefore, a different
approach was taken. The idea was to let the 256 distinct levels represent
intensity values on a perceptually linear scale instead, in which case the
vast majority of images could be adequately represented on just 8 bits per
colour channel.</p><p class=important>The transformation used to represent the <em>physically linear</em> intensity data
either generated synthetically via an algorithm or captured by a linear
device (such as a CMOS of a digital camera or a scanner) with the discrete
values of the <em>perceptually linear</em> scale is called <strong>gamma encoding</strong>.</p><p>The 24-bit <a href=https://en.wikipedia.org/wiki/RGB_color_model#Video_framebuffer>RGB colour
model</a>
(RGB24) used on virtually all consumer level electronic devices uses 8-bit
<a href=https://en.wikipedia.org/wiki/RGB_color_model#Nonlinearity>gamma encoded
values</a> per
channel to represent light intensities. If you recall what we discussed
earlier, this means that pixels with RGB(128, 128, 128) will <em>not</em> emit
approximately 50% the light energy of pixels with RGB(255, 255, 255), but only
about 22%! That makes perfect sense! Because of the non-linear nature of human
vision, a light source needs to be attenuated to about 22% of its original
light intensity to appear half as bright to humans. RGB(128, 128, 128)
<em>appears</em> to be half as bright as RGB(255, 255, 255) to us! If you find this
confusing, reflect a bit on it because it&rsquo;s crucial to have a solid
understanding of what has been discussed so far (trust me, it will only get
more confusing).</p><p>Of course, gamma encoding is always done with the assumption that the image is
ultimately meant to be viewed by humans on computer screens. In some way, you
can think of it as a lossy MP3 like compression but for images. For other
purposes (e.g. scientific analysis or images meant for further
post-processing), using floats and sticking with the linear scale is often
a much better choice, as we&rsquo;ll later see.</p><h3 id=the-gamma-transfer-function>The gamma transfer function</h3><p>The process of converting values from linear space to gamma space is called
<strong>gamma encoding</strong> (or <em>gamma compression</em>), and the reverse <strong>gamma
decoding</strong> (or <em>gamma expansion</em>).</p><p>The formulas for these two operations are very simple, we only need to use the
aforementioned power law function:</p><p>$$\V_{\encoded} = \V_{\linear} ^ {1/\γ}$$</p><p>$$\V_{\linear} = \V_{\encoded} ^ {\γ}$$</p><p>The <strong>standard gamma (γ)</strong> value to use in computer display systems is
<strong>2.2</strong>. The main reason for this is because a gamma of 2.2 approximately
matches the power law sensitivity of human vision. The exact value that should
be used varies from person to person and also depends on the lighting
conditions and other factors, but a standard value had to be chosen and 2.2
was good enough. Don&rsquo;t be too hung up on this.</p><p>Now, a very important point that many texts fail to mention is that the input
values have to be in the 0 to 1 range and the output will be consequently
mapped to the same range too. From this follows the slightly counter-productive
fact that gamma values between 0 and 1 are used for <strong>encoding</strong>
(compression) and greater than 1 for <strong>decoding</strong> (expansion).
The below charts demonstrate the gamma transfer functions for encoding and
decoding, plus the trivial linear gamma (γ=1.0) case:</p><figure class=image><object data=img/gamma.svg type=image/svg+xml style=width:100%></object><figcaption style=width:100%;text-align:center><p>Figure 6 &mdash; Gamma transfer functions
(<a href=src/gammatransfer.nim>Nim source code</a>)</p><p>a) encoding gamma, or gamma compression (γ=1/2.2≈0.4545)<br>b) linear gamma (γ=1.0)<br>c) decoding gamma, or gamma expansion (γ=2.2)</p></figcaption></figure><p>We have only seen greyscale examples so far, but there&rsquo;s nothing special about
RGB images&mdash;we just simply need to encode or decode each colour channel
individually using the same method.</p><h3 id=gamma-vs-srgb>Gamma vs sRGB</h3><p><a href=https://en.wikipedia.org/wiki/SRGB>sRGB</a> is a colour space that is the
de-facto standard for consumer electronic devices nowadays, including
monitors, digital cameras, scanners, printers and handheld devices. It is
also the standard colour space for images on the Internet.</p><p>The sRGB specification defines what gamma to use for encoding and decoding
sRGB images (among other things such as colour gamut, but these are not
relevant to our current discussion). sRGB gamma is very close to a standard
gamma of 2.2, but it has a short linear segment in the very dark range to
avoid a slope of infinity at zero (this is more convenient in numeric
calculations). The formulas to convert from linear to sRGB and back can be
found
<a href=https://en.wikipedia.org/wiki/SRGB#Specification_of_the_transformation>here</a>.</p><p>You don&rsquo;t actually need to understand all these finer details; the important
thing to know is that in 99% of the cases you&rsquo;ll want to use sRGB instead of
plain gamma. The reason for this is that all graphics cards have hardware sRGB
support since 2005 or so, so decoding and encoding is virtually for free most
of the time. The native colour space of your monitor is most likely sRGB
(unless it&rsquo;s a professional monitor for graphics, photo or video work) so if
you just chuck an sRGB encoded pixel data into the framebuffer, the resulting
image will look correct on the screen (given the monitor is properly
calibrated). Popular image formats such as JPEG and PNG can store colour space
information, but very often images don&rsquo;t contain such data, in which case
virtually all image viewers and browsers will interpret them as sRGB by
convention.</p><h3 id=gamma-calibration>Gamma calibration</h3><p>We have talked about gamma encoding and decoding so far, but what is <strong>gamma
calibration</strong> then? I found this bit slightly confusing too, so let me clear
it up.</p><p>As mentioned, 99% of all monitors today use the sRGB colour space natively,
but due to manufacturing inaccuracies most monitors would benefit from some
additional gamma calibration to achieve the best results. Now, if you never
calibrated your monitor, that doesn&rsquo;t mean that it will not use gamma! That is
simply impossible, most CRT and LCD displays in the past and present have been
designed and manufactured to operate in sRGB.</p><p>Think of gamma calibration as fine tuning. Your monitor will always operate in
sRGB, but by calibrating it (either in the video card driver or on the OS
level) the monitor&rsquo;s gamma transfer curve will more closely match the ideal
gamma transfer function we discussed earlier. Also, years ago it was possible
to shoot yourself in the foot in various creative ways by applying multiple
gamma correction stages in the graphics pipeline (e.g. video card, OS and
application level), but fortunately this is handled more intelligently
nowadays. For example, on my Windows 7 box, if I turn on gamma calibration in
the NVIDIA Control Panel then the OS level calibration will be disabled and
vice versa.</p><h3 id=processing-gamma-encoded-images>Processing gamma-encoded images</h3><p>So, if virtually the whole world defaults to sRGB, what is exactly the
problem? If our camera writes sRGB JPEG files, we can just decode the JPEG
data, copy it into the framebuffer of the graphics card and the image would be
displayed correctly on our sRGB LCD monitor (where &ldquo;correctly&rdquo; means it would
more or less accurately represent the photographed real-world scene).</p><p>The problem will happen in the moment we start running any image processing
algorithms on our sRGB pixel buffer directly. Remember, gamma encoding is
a non-linear transformation and sRGB encoding is basically just a funky way of
doing gamma encoding of around γ=1/2.2. Virtually all image processing
algorithms you will find in any computer graphics text will assume pixel data
with <em>linearly encoded light intensities</em>, which means that feeding these
algorithms with sRGB encoded data will render the results subtly&mdash;or in
some cases quite obviously&mdash;wrong! This includes resizing, blurring,
compositing, interpolating between pixel values, antialiasing and so on, just
to name the most common operations!</p><h2 id=effects-of-gamma-incorrectness>Effects of gamma-incorrectness</h2><p>Alright, enough theory talk, show me how these errors actually look like!
That&rsquo;s exactly what we&rsquo;ll do in this section; we will examine the most common
scenarios when running image processing algorithms directly on sRGB data would
manifest in incorrect results. Apart from illustrative purposes, these
examples are also useful for spotting gamma-incorrect behaviour or bugs in
drawing programs and image processing libraries.</p><p>It must be noted that I have chosen examples that clearly demonstrate the
problems with gamma-incorrectness. In most cases, the issues are the most
obvious when using vivid, saturated colours. With more muted colours, the
differences might be less noticeable or even negligible <em>in some cases</em>.
However, the errors are always present, and image processing programs should work
correctly for all possible inputs, not just okayish for 65.23% of all possible
images&mldr; Also, in the area of physically based rendering gamma correctness is
an absolute must, as we&rsquo;ll see.</p><h3 id=gradients>Gradients</h3><p>The image below shows the difference between gradients calculated in linear
(top gradient) and sRGB space (bottom gradient). Note how direct interpolation
on the sRGB values yields much darker and sometimes more saturated looking
images.</p><p>Just going by the looks, one might prefer the look of the sRGB-space versions,
especially for the last two. However, that&rsquo;s not how light would behave
in the real world (imagine two coloured light sources illuminating a white
wall; the colours would mix as in the linear-space case).</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/gradient.png alt="Figure 7 &mdash; For each gradient-pair, the top gradient is a linear interpolation between two colours in linear space, then the result converted to sRGB (gamma-correct). The bottom gradients are the results of interpolating between the exact same colours but directly in sRGB space (gamma-incorrect)" style=width:70% loading=lazy><figcaption style=width:70%;text-align:center>Figure 7 &mdash; For each gradient-pair, the top gradient is a linear
interpolation between two colours in linear space, then the result converted
to sRGB (gamma-correct). The bottom gradients are the results of
interpolating between the exact same colours but directly in sRGB space
(gamma-incorrect) (<a href=src/gradient.nim>Nim source code</a>).</figcaption></figure><p>Almost everybody does this the wrong way: CSS gradients and transitions are
wrong (see <a href=https://lists.w3.org/Archives/Public/www-style/2012Jan/0607.html>this
thread</a> for
details), Photoshop is wrong (as of version CS6) and there&rsquo;s not even an option
to fix it.</p><p>Two drawing programs that got this (and gamma-correctness in general) right
are <a href=https://krita.org/>Krita</a> and <a href=https://www.pixelmator.com/>Pixelmator</a>.
SVG also <a href=https://www.w3.org/TR/SVG/painting.html#ColorInterpolationProperties>let&rsquo;s the user to
specify</a>
whether to use linear or sRGB-space interpolations for gradients, compositing
and animations.</p><h3 id=colour-blending>Colour blending</h3><p>Drawing with soft brushes in gamma-incorrect drawing programs can result in
weird darkish transition bands with certain vivid colour combinations.
This is really a variation of the gradient problem if you think about it (the
transition band of a soft brush is nothing else than a small gradient).</p><p>Some random people claimed on the Adobe forums that by doing this Photoshop is
really mimicking how mixing paints would work in real life. Well, no, it
has nothing to do with that. It&rsquo;s just the result of naive programming to work
directly on the sRGB pixel data and now we&rsquo;re stuck with that as the default
legacy behaviour.</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/color-blending.jpg alt="Figure 8 &mdash; Effects of gamma-incorrect colour blending. On the left
gamma-correct image, the option Blend RGB Colors Using Gamma 1.0 was
enabled in Photoshop CS6, on the right it was disabled (that&rsquo;s the default
gamma-incorrect legacy mode)." style=width:90% loading=lazy><figcaption style=width:90%;text-align:center>Figure 8 &mdash; Effects of gamma-incorrect colour blending. On the left
gamma-correct image, the option <em>Blend RGB Colors Using Gamma 1.0</em> was
enabled in Photoshop CS6, on the right it was disabled (that&rsquo;s the default
gamma-incorrect legacy mode).</figcaption></figure><h3 id=alpha-blending--compositing>Alpha blending / compositing</h3><p>As another variation on colour blending, let&rsquo;s see how alpha blending holds
up. We&rsquo;ll examine some coloured rectangles first. As expected, the
gamma-correct image on the left mimics how light would behave in real life,
while the sRGB space blending on the right exhibits some weird hue and
brightness shifts.</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/opacity.png alt="Figure 9 &mdash; Effects of gamma-incorrect alpha blending. For each vertical
bar pair, the top one is drawn with 100% opacity and bottom one with 50%.
The left image is the gamma-correct one. The test was done in Photoshop CS6,
similarly to Figure 8." style=width:90% loading=lazy><figcaption style=width:90%;text-align:center>Figure 9 &mdash; Effects of gamma-incorrect alpha blending. For each vertical
bar pair, the top one is drawn with 100% opacity and bottom one with 50%.
The left image is the gamma-correct one. The test was done in Photoshop CS6,
similarly to Figure 8.</figcaption></figure><p>The appearance of false colours is also noticeable when blending two photos
together. On the gamma-correct image on the left, the skin tones and the reds
and yellows are preserved but faded into the bluish image in a natural way,
while on the right image there&rsquo;s a noticeable overall greenish cast. Again,
this might be an effect you like, but it&rsquo;s not how accurate alpha
compositing should work.</p><figure class=image><a class=largeimg href=/2016/09/21/what-every-coder-should-know-about-gamma/img/blending.jpg data-pswp-width=1260 data-pswp-height=862><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/blending.jpg alt="Figure 10 &mdash; Effects of gamma-incorrectness when compositing photographic images (by yours truly). The two original images from the top row are laid on top of each other in the bottom row, with the blueish image on top having 60% opacity. The left image is the gamma-correct one. Tested with Photoshop CS6. (Click on the image to enlarge it to see the details better.)" style=width:100% loading=lazy></a><figcaption style=width:90%;text-align:center>Figure 10 &mdash; Effects of gamma-incorrectness when compositing photographic
images (by <a href=https://photo.johnnovak.net/>yours truly</a>). The two original
images from the top row are laid on top of each other in the bottom row,
with the blueish image on top having 60% opacity. The left image is the
gamma-correct one. Tested with Photoshop CS6. (Click on the image to enlarge
it to see the details better.</figcaption></figure><h3 id=image-resizing>Image resizing</h3><p>These examples will only work if your browser doesn&rsquo;t do any rescaling on the
images below. Also, note that screens of mobile devices are more inaccurate
with regards to gamma than regular monitors, so for best results try to view
this on a desktop computer.</p><p>The image below contains a simple black and white checkerboard pixel pattern
(100% zoom on the left, 400% zoom on the right). The black pixels are
RGB(0,0,0), the minimum light intensity your monitor is capable of producing,
and the white ones RGB(255,255,255), which is the maximum intensity. Now, if
you squint a little, your eyes will blur (average) the light coming from the
image, so you will see a grey that&rsquo;s halfway in intensity between absolute
black and white (therefore it&rsquo;s referred to as <strong>50% grey</strong>).</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/resize-large.png alt="Figure 11 &mdash; Black and white checkerboard pixel pattern frequently used in
simple gamma calibration programs. The averaged light emission of the area
occupied by the pattern is equal to that of a solid 50% grey square. The
right image shows the pattern at 400% magnification." style=width:220px loading=lazy><figcaption style=width:80%;text-align:center>Figure 11 &mdash; Black and white checkerboard pixel pattern frequently used in
simple gamma calibration programs. The averaged light emission of the area
occupied by the pattern is equal to that of a solid 50% grey square. The
right image shows the pattern at 400% magnification.</figcaption></figure><p>From this follows that if we resized the image by 50%, a similar averaging
process should happen, but now algorithmically on the pixel data. We expect
to get a solid rectangle filled with the same 50% grey that we saw when we
squinted.</p><p>Let&rsquo;s try it out! On the image below, <em>A</em> is the checkerboard pattern, <em>B</em> the
result of resizing the pattern by 50% directly in sRGB-space (using bicubic
interpolation), and <em>C</em> the resizing it in linear space, then converted to
sRGB.</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/resize.png alt="Figure 12 &mdash; Effects of gamma-incorrect image resizing. A is the pixel
checkerboard pattern, B the gamma-incorrect result of resizing the image
in sRGB space (Photoshop CS6 in 8-bit RGB mode), and C the gamma-correct
result of converting the image to linear space before resizing, then back to
sRGB at the end (Photoshop CS6 in 32-bit RGB mode)." style=width:316px loading=lazy><figcaption style=width:80%;text-align:center>Figure 12 &mdash; Effects of gamma-incorrect image resizing. <em>A</em> is the pixel
checkerboard pattern, <em>B</em> the gamma-incorrect result of resizing the image
in sRGB space (Photoshop CS6 in 8-bit RGB mode), and <em>C</em> the gamma-correct
result of converting the image to linear space before resizing, then back to
sRGB at the end (Photoshop CS6 in 32-bit RGB mode).</figcaption></figure><p>Unsurprisingly, <em>C</em> gives the correct result, but the shade of grey might not
be an exact match for the blurred checkerboard pattern on your monitor if
it&rsquo;s not properly gamma-calibrated. Even the math shows this clearly: a 50%
grey pixel that emits half as much light as a white pixel should have a RGB
value of around (186,186,186), gamma-encoded:</p><p>$$0.5^{1/2.2} ≈ 0.72974$$
$$0.72974·255 = 186$$</p><p>(Don&rsquo;t worry that on the image the 50% grey is RGB(187,187,187). That small
difference is because the image is sRGB-encoded, but I used the much simpler
gamma formula for my calculation here.)</p><p>Gamma-incorrect resizing can also result in weird hue shifts on some images.
For more details, read <a href=http://www.ericbrasseur.org/gamma.html>Eric Brasseur&rsquo;s excellent
article</a> on the matter.</p><h3 id=antialiasing>Antialiasing</h3><p>I guess it&rsquo;s no surprise at this point that antialiasing is no exception when
it comes to gamma-correctness. Antialiasing in γ=2.2 space results in overly
dark &ldquo;smoothing pixels&rdquo; (right image); the text appears too heavy, almost as
if it was bold. Running the algorithm in linear space produces much better
results (left image), although in this case the font looks a bit too thin.
Interestingly, Photoshop antialiases text using γ=1.42 by default, and this
indeed seems to yield the best looking results (middle image). The reason for
this is that most fonts have been designed for gamma-incorrect font
rasterizers, hence if you use linear space (correctly), then the fonts will
look thinner than they should.</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/antialias.png alt="Figure 13 &mdash; Effects of gamma-incorrectness on text antialiasing. The left
image was rendered with the option Blend Text Colors Using Gamma set to
1.0, the middle one with 1.45, and the right one with 2.2." style=width:623px loading=lazy><figcaption style=width:623px;text-align:center>Figure 13 &mdash; Effects of gamma-incorrectness on text antialiasing. The left
image was rendered with the option <em>Blend Text Colors Using Gamma</em> set to
1.0, the middle one with 1.45, and the right one with 2.2.</figcaption></figure><h3 id=physically-based-rendering>Physically-based rendering</h3><p>If there&rsquo;s a single area where gamma-correctness is an absolute must, that&rsquo;s
physically-based rendering (PBR). To obtain realistic looking results, gamma
should be handled correctly throughout the whole graphics pipeline. There&rsquo;s
so many ways to screw this up, but these are the two most common ways:</p><ul><li>Doing the calculations in linear space but failing to convert the final
image to sRGB and then &ldquo;tweaking&rdquo; various material and lighting parameters
to compensate.</li><li>Failing to convert sRGB texture images to linear space (or set the sRGB flag
when hardware acceleration is used).</li></ul><p>These two basic errors are then usually combined in various interesting ways,
but the end result would invariably fail to resemble a realistic looking scene
(e.g. quadratic light falloff will not appear quadratic anymore, highlights
will be overblown and will exhibit some weird hue and saturation shifts etc.)</p><p>To demonstrate the first mistake using my own <a href=/tags/ray-tracing/>ray
tracer</a>, the left image below shows a very simple but
otherwise quite natural looking image in terms of physical lighting accuracy.
This rendering took place in linear space and then the contents of the
framebuffer were converted to sRGB before writing it to disk.</p><p>On the right image, however, this last conversion step was omitted and I tried
to tweak the light intensities in an attempt to match the overall brightness
of the gamma-correct image. Well, it&rsquo;s quite apparent that this is not going
to work. Everything appears too contrasty and oversaturated, so we&rsquo;d probably
need to desaturate all material colours a bit maybe use some more fill lights
to come closer to the look of the left image. But this is a losing battle; no
amount of tweaking will make the image correct in the physical sense, and even
if we got it to an acceptable level for one particular scene with a particular
lighting setup, any further changes to the scene would potentially necessitate
another round of tweaks to make the result look realistic again. Even more
importantly, the material and lighting parameters we would need to choose
would be completely devoid of any physical meaning whatsoever; they&rsquo;ll be just
a random set of numbers that happen to produce an OK looking image <em>for that
particular scene</em>, and thus not transferable to other scenes or lighting
conditions. It&rsquo;s a lot of wasted energy to work like that.</p><figure class=image><a class=largeimg href=/2016/09/21/what-every-coder-should-know-about-gamma/img/badgamma.png data-pswp-width=1237 data-pswp-height=400><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/badgamma.png alt="Figure 14 &mdash; Effects of gamma-incorrect rendering on diffuse spheres. The
gamma-incorrect image on the right shows an unsuccesful attempt at matching
the look of the gamma-correct one on the left by tweaking the light
intensities alone." style=width:100% loading=lazy></a><figcaption style=width:95%;text-align:center>Figure 14 &mdash; Effects of gamma-incorrect rendering on diffuse spheres. The
gamma-incorrect image on the right shows an unsuccesful attempt at matching
the look of the gamma-correct one on the left by tweaking the light
intensities alone.</figcaption></figure><p>It&rsquo;s also important to point out that incorrect gamma handling in 3D rendering
is one of the main culprits behind the &ldquo;fake plasticky CGI look&rdquo; in some
(mostly older) games. As illustrated on the image below, rendering realistic
looking human skin is almost impossible with a gamma-incorrect workflow; the
highlights will just never look right. This gave birth to questionable
practices such as compensating for the wrong highlights in the specular maps
with inverted hues and all sorts of other nastiness instead of fixing the
problem right at the source&mldr;</p><figure class=image><img src=/2016/09/21/what-every-coder-should-know-about-gamma/img/lineargammahead.png alt="Figure 15 &mdash; Effects of gamma-incorrect rendering on a human head. On the top, a real looking human head; on the bottom, a wax figure approximation." style=width:90% loading=lazy><figcaption style=width:90%;text-align:center>Figure 15 &mdash; Effects of gamma-incorrect rendering on a human head. On the
top, a real looking human head; on the bottom, a wax figure approximation.
(Image from the
<a href=https://docs.unity3d.com/Manual/LinearLighting.html>Unity3D manual</a>)</figcaption></figure><h2 id=conclusion>Conclusion</h2><p>This is pretty much all there is to gamma encoding and decoding.
Congratulations for making it so far, now you&rsquo;re an officially certified
gamma-compliant developer! :)</p><p>To recap, the only reason to use gamma encoding for digital images is because
it allows us to store images more efficiently on a limited bit-length. It
takes advantage of a characteristic of human vision that we perceive
brightness in a logarithmic way. Most image processing algorithms expect pixel
data with linearly encoded light intensities, therefore gamma-encoded images
need to be gamma-decoded (converted to linear space) first before we can run
these algorithms on them. Often the results need to be converted back to
gamma-space to store them on disk or to display them on graphics hardware that
expects gamma-encoded values (most consumer-level graphics hardware fall into
this category). The de-facto standard sRGB colourspace uses a gamma of
approximately 2.2. That&rsquo;s the default colourspace for images on the Internet
and for most monitors, scanners and printers. When in doubt, just use sRGB.</p><p>From the end-user perspective, keep in mind that most applications and
software libraries do not handle gamma correctly, therefore always make sure
to do extensive testing before adopting them into your workflow. For a proper
linear workflow, <em>all</em> software used in the chain has to be 100%
gamma-correct.</p><p>And if you&rsquo;re a developer working on graphics software, please make sure
you&rsquo;re doing the correct thing. Be gamma-correct and always explicitly state
your assumptions about the input and output colour spaces in the software&rsquo;s
documentation.</p><p>May all your lights be linear! :)</p><hr><section class=links><h2 id=references--further-reading>References & further reading</h2><h3 id=general-gammasrgb-info>General gamma/sRGB info</h3><ul><li><p><a href=http://www.poynton.com/GammaFAQ.html>Charles Poynton &ndash; Gamma FAQ</a></p></li><li><p><a href=https://www.cambridgeincolour.com/tutorials/gamma-correction.htm>Cambridge in Colour &ndash; Understanding gamma correction</a></p></li><li><p><a href=http://gamedevdaily.io/the-srgb-learning-curve-773b7f68cf7a#.ssgyxju0h>Tom Forsynth &ndash; The sRGB Learning Curve</a></p></li><li><p><a href=https://ninedegreesbelow.com/photography/linear-gamma-blur-normal-blend.html>Nine Degrees Below &ndash; Linear Gamma vs Higher Gamma RGB Color Spaces: Gaussian Blur and Normal Blend Mode</a></p></li><li><p><a href=http://www.ericbrasseur.org/gamma.html>Eric Brasseur &ndash; Gamma error in picture scaling</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/Gamma_correction>Wikipedia &ndash; Gamma correction</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/SRGB>Wikipedia &ndash; sRGB</a></p></li><li><p><a href=https://en.wikipedia.org/wiki/RGB_color_model>Wikipedia &ndash; RGB color model</a></p></li></ul><h3 id=linear-lighting--workflow-lwf>Linear lighting & workflow (LWF)</h3><ul><li><p><a href=https://frictionalgames.blogspot.com/2013/11/tech-feature-linear-space-lighting.html>In the Games of Madness &ndash; Tech Feature: Linear-space lighting</a></p></li><li><p><a href=https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-24-importance-being-linear>Larry Gritz, GPU Gems 3 &ndash; Chapter 24. The Importance of Being Linear</a></p></li><li><p><a href="https://www.peachpit.com/articles/article.aspx?p=2165641">Jeremy Birn &ndash; Top Ten Tips for More Convincing Lighting and Rendering</a> – (Section 1. Use a Linear Workflow)</p></li><li><p><a href=https://docs.unity3d.com/Manual/LinearLighting.html>Unity Documentation &ndash; Linear Rendering</a></p></li><li><p><a href=https://spitzak.github.io/conversion/index.html>Bill Spitzak &ndash; High-speed Conversion of Floating Point Images to 8-bit</a></p></li><li><p><a href=https://renderman.pixar.com/view/LinearWorkflow>Renderman &ndash; Linear Workflow</a></p></li><li><p><a href=https://blackhole12.blogspot.com.au/2011/12/great-mystery-of-linear-gradient.html>Eric McClure &ndash; The Great Mystery of Linear Gradient Lighting</a></p></li></ul><h3 id=bonus-stuff>Bonus stuff</h3><ul><li><p><a href=https://www.rle.mit.edu/stir/documents/VarshneyS_Significance2013.pdf>Lav R. Varshney, John Z. Sun &ndash; Why do we perceive logarithmically? [PDF]</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Stevens'_power_law">Wikipedia &ndash; Stevens' power law</a></p></li><li><p><a href=https://docs.krita.org/en/general_concepts/colors/color_managed_workflow.html>Krita Manual &ndash; Color Managed Workflow</a></p></li><li><p><a href=https://ptgmedia.pearsoncmg.com/imprint_downloads/peachpit/peachpit/lightroom4/pdf_files/LightroomRGB_Space.pdf>The Adobe Photoshop Lightroom Book &ndash; The Lightroom RGB space [PDF]</a></p></li><li><p><a href=https://www.openexr.com/>OpenEXR</a></p></li><li><p><a href=https://cinematiccolor.org/>Cinematic Color &ndash; Motion-Picture Color Management</a></p></li></ul></section><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Only if your operating system is Mac OS X 10.6 or higher or Linux.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section><section class=comments><h2>Comments</h2><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//johnnovak.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></article></div></div></body><script type=module>
    import PhotoSwipeLightbox from '/js/lib/photoswipe-lightbox.esm.min.js';

    const lightbox = new PhotoSwipeLightbox({
      gallery: 'body',
      children: 'figure > a',
      showHideAnimationType: 'none',
      pswpModule: () => import('/js/lib/photoswipe.esm.min.js')
    });

    lightbox.init();
  </script></html>